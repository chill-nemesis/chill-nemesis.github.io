<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Horizon: HORIZON::ALGORITHM::CONCURRENT::concurrent_vector&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Horizon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector&lt; T, Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group__horizon.html">Horizon</a> &raquo; <a class="el" href="group__group__module__algorithm.html">Algorithm</a> &raquo; <a class="el" href="group__group__algorithm__concurrent.html">Concurrent</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A concurrent vector.  
 <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_base</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a406e93738ee7becd00e51ce7094a5184"><td class="memItemLeft" align="right" valign="top"><a id="a406e93738ee7becd00e51ce7094a5184"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a406e93738ee7becd00e51ce7094a5184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b43e3292c37e54a8cbbe2ede38973"><td class="memItemLeft" align="right" valign="top"><a id="a422b43e3292c37e54a8cbbe2ede38973"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Alloc</td></tr>
<tr class="separator:a422b43e3292c37e54a8cbbe2ede38973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d34549d7f074caf333038cf5bbaeb1"><td class="memItemLeft" align="right" valign="top"><a id="a38d34549d7f074caf333038cf5bbaeb1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>container_type</b> = std::vector&lt; value_type, allocator_type &gt;</td></tr>
<tr class="separator:a38d34549d7f074caf333038cf5bbaeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845d6db1728836da47b1316e471e994c"><td class="memItemLeft" align="right" valign="top"><a id="a845d6db1728836da47b1316e471e994c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename container_type::size_type</td></tr>
<tr class="separator:a845d6db1728836da47b1316e471e994c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554574ee5a763c596b386fb7cf72df25"><td class="memItemLeft" align="right" valign="top"><a id="a554574ee5a763c596b386fb7cf72df25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a554574ee5a763c596b386fb7cf72df25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14794c04d300453d3c76e49e92c809b3"><td class="memItemLeft" align="right" valign="top"><a id="a14794c04d300453d3c76e49e92c809b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = value_type const  &amp;</td></tr>
<tr class="separator:a14794c04d300453d3c76e49e92c809b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92eb7e0cf4b2d8feb04cfa73f5be7467"><td class="memItemLeft" align="right" valign="top"><a id="a92eb7e0cf4b2d8feb04cfa73f5be7467"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>access_type</b> = size_type</td></tr>
<tr class="separator:a92eb7e0cf4b2d8feb04cfa73f5be7467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8d01905bd03628073e4e03c1e65bb1"><td class="memItemLeft" align="right" valign="top"><a id="a0d8d01905bd03628073e4e03c1e65bb1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = typename container_type::iterator</td></tr>
<tr class="separator:a0d8d01905bd03628073e4e03c1e65bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dc9f6eba11b840cc06e2a8996c9eda"><td class="memItemLeft" align="right" valign="top"><a id="ac7dc9f6eba11b840cc06e2a8996c9eda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = typename container_type::const_iterator</td></tr>
<tr class="separator:ac7dc9f6eba11b840cc06e2a8996c9eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c53d2b1fc40766322774ea088931da"><td class="memItemLeft" align="right" valign="top"><a id="ae3c53d2b1fc40766322774ea088931da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = typename container_type::reverse_iterator</td></tr>
<tr class="separator:ae3c53d2b1fc40766322774ea088931da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32776e94813d5377e352183ad7617c18"><td class="memItemLeft" align="right" valign="top"><a id="a32776e94813d5377e352183ad7617c18"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = typename container_type::const_reverse_iterator</td></tr>
<tr class="separator:a32776e94813d5377e352183ad7617c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d82b4bcf23db039e00e34a1438e4576"><td class="memItemLeft" align="right" valign="top"><a id="a5d82b4bcf23db039e00e34a1438e4576"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> = std::unique_lock&lt; std::mutex &gt;</td></tr>
<tr class="memdesc:a5d82b4bcf23db039e00e34a1438e4576"><td class="mdescLeft">&#160;</td><td class="mdescRight">The access token type used to mark ownership. <br /></td></tr>
<tr class="separator:a5d82b4bcf23db039e00e34a1438e4576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5fcaac1309122018e9257f59ddad32"><td class="memItemLeft" align="right" valign="top"><a id="a6c5fcaac1309122018e9257f59ddad32"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> = std::chrono::nanoseconds</td></tr>
<tr class="memdesc:a6c5fcaac1309122018e9257f59ddad32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time type used for timeouts. <br /></td></tr>
<tr class="separator:a6c5fcaac1309122018e9257f59ddad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f325cf82ed4ac2a6b7ba0f73b1b7512"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a5f325cf82ed4ac2a6b7ba0f73b1b7512">capacity</a> () const</td></tr>
<tr class="separator:a5f325cf82ed4ac2a6b7ba0f73b1b7512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001460c88a8f3512562df1ba1bb87dc7"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a001460c88a8f3512562df1ba1bb87dc7">capacity</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const</td></tr>
<tr class="memdesc:a001460c88a8f3512562df1ba1bb87dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the capacity of the container if it is owned by the calling thread.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a001460c88a8f3512562df1ba1bb87dc7">More...</a><br /></td></tr>
<tr class="separator:a001460c88a8f3512562df1ba1bb87dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b1f7fb4eb5e9474eaf03877d86af79"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a99b1f7fb4eb5e9474eaf03877d86af79">size</a> () const</td></tr>
<tr class="separator:a99b1f7fb4eb5e9474eaf03877d86af79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3322b1514deeb3e97b6cbdbacc87a11b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a3322b1514deeb3e97b6cbdbacc87a11b">size</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const</td></tr>
<tr class="memdesc:a3322b1514deeb3e97b6cbdbacc87a11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of hte container if it is owned by the calling thread.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a3322b1514deeb3e97b6cbdbacc87a11b">More...</a><br /></td></tr>
<tr class="separator:a3322b1514deeb3e97b6cbdbacc87a11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3153e8a8613f4af6a1b5d094cc748364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a3153e8a8613f4af6a1b5d094cc748364">empty</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const override</td></tr>
<tr class="separator:a3153e8a8613f4af6a1b5d094cc748364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e98a10b51741a020a47597ab7a52307"><td class="memItemLeft" align="right" valign="top"><a id="a5e98a10b51741a020a47597ab7a52307"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a5e98a10b51741a020a47597ab7a52307">resize</a> (size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a99b1f7fb4eb5e9474eaf03877d86af79">size</a>)</td></tr>
<tr class="memdesc:a5e98a10b51741a020a47597ab7a52307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container. <br /></td></tr>
<tr class="separator:a5e98a10b51741a020a47597ab7a52307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6cb87faa9de996dbdb4f950a7cf0c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a2c6cb87faa9de996dbdb4f950a7cf0c7">resize</a> (size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a99b1f7fb4eb5e9474eaf03877d86af79">size</a>, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const</td></tr>
<tr class="memdesc:a2c6cb87faa9de996dbdb4f950a7cf0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container if it is owned by the calling thread.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a2c6cb87faa9de996dbdb4f950a7cf0c7">More...</a><br /></td></tr>
<tr class="separator:a2c6cb87faa9de996dbdb4f950a7cf0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6672ece8fd1f6045feeb51112f1b5fd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a6672ece8fd1f6045feeb51112f1b5fd0">resize</a> (size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a99b1f7fb4eb5e9474eaf03877d86af79">size</a>, value_type const &amp;def)</td></tr>
<tr class="memdesc:a6672ece8fd1f6045feeb51112f1b5fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container and initialises with a default element.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a6672ece8fd1f6045feeb51112f1b5fd0">More...</a><br /></td></tr>
<tr class="separator:a6672ece8fd1f6045feeb51112f1b5fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc71b02801922dd66ac846c5c6ed5e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#adc71b02801922dd66ac846c5c6ed5e23">resize</a> (size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a99b1f7fb4eb5e9474eaf03877d86af79">size</a>, value_type const &amp;def, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token)</td></tr>
<tr class="memdesc:adc71b02801922dd66ac846c5c6ed5e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container and initialises with a default element if it is owned by the calling thread.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#adc71b02801922dd66ac846c5c6ed5e23">More...</a><br /></td></tr>
<tr class="separator:adc71b02801922dd66ac846c5c6ed5e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ae63c9ffbe2ea67ece0521a027072f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#ab7ae63c9ffbe2ea67ece0521a027072f">reserve</a> (size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a99b1f7fb4eb5e9474eaf03877d86af79">size</a>)</td></tr>
<tr class="memdesc:ab7ae63c9ffbe2ea67ece0521a027072f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space in the container without initialising.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#ab7ae63c9ffbe2ea67ece0521a027072f">More...</a><br /></td></tr>
<tr class="separator:ab7ae63c9ffbe2ea67ece0521a027072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffd6ddb2b07bf64e55f83fc866b464e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a3ffd6ddb2b07bf64e55f83fc866b464e">reserve</a> (size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a99b1f7fb4eb5e9474eaf03877d86af79">size</a>, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token)</td></tr>
<tr class="memdesc:a3ffd6ddb2b07bf64e55f83fc866b464e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space in the container without initialising.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a3ffd6ddb2b07bf64e55f83fc866b464e">More...</a><br /></td></tr>
<tr class="separator:a3ffd6ddb2b07bf64e55f83fc866b464e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b543d8d5bbcb0f285014615e9fc865d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a3b543d8d5bbcb0f285014615e9fc865d">push_back</a> (value_type const &amp;item)</td></tr>
<tr class="memdesc:a3b543d8d5bbcb0f285014615e9fc865d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the given element at the end of the vector.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a3b543d8d5bbcb0f285014615e9fc865d">More...</a><br /></td></tr>
<tr class="separator:a3b543d8d5bbcb0f285014615e9fc865d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718608315bbe36aff295618a23cb67bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a718608315bbe36aff295618a23cb67bb">push_back</a> (value_type const &amp;item, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token)</td></tr>
<tr class="memdesc:a718608315bbe36aff295618a23cb67bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the given element at the end of the vector if the vector is owned by the calling thread.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a718608315bbe36aff295618a23cb67bb">More...</a><br /></td></tr>
<tr class="separator:a718608315bbe36aff295618a23cb67bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b78f7d6d4e94a9c01fb5c2f19b6c61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#ae4b78f7d6d4e94a9c01fb5c2f19b6c61">push_back</a> (value_type &amp;&amp;item)</td></tr>
<tr class="memdesc:ae4b78f7d6d4e94a9c01fb5c2f19b6c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace creates the given element at the end of the vector.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#ae4b78f7d6d4e94a9c01fb5c2f19b6c61">More...</a><br /></td></tr>
<tr class="separator:ae4b78f7d6d4e94a9c01fb5c2f19b6c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac1708467102268ce05f9e27052fc8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#adac1708467102268ce05f9e27052fc8f">push_back</a> (value_type &amp;&amp;item, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token)</td></tr>
<tr class="memdesc:adac1708467102268ce05f9e27052fc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace creates the given element at the end of the vector if the container is owned by the calling thread.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#adac1708467102268ce05f9e27052fc8f">More...</a><br /></td></tr>
<tr class="separator:adac1708467102268ce05f9e27052fc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16feb021870b68236ed0797b853f1358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a16feb021870b68236ed0797b853f1358">SwapElements</a> (access_type const &amp;first, access_type const &amp;second)</td></tr>
<tr class="memdesc:a16feb021870b68236ed0797b853f1358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two elements of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a16feb021870b68236ed0797b853f1358">More...</a><br /></td></tr>
<tr class="separator:a16feb021870b68236ed0797b853f1358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1507213297533ff8605803be7b89182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#ab1507213297533ff8605803be7b89182">SwapElements</a> (access_type const &amp;first, access_type const &amp;second, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token)</td></tr>
<tr class="memdesc:ab1507213297533ff8605803be7b89182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two elements of the container if the container is owned by the calling thread.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#ab1507213297533ff8605803be7b89182">More...</a><br /></td></tr>
<tr class="separator:ab1507213297533ff8605803be7b89182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef16f47d963dbc40901d60569efd5c7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#aef16f47d963dbc40901d60569efd5c7e">SwapElements</a> (access_type const &amp;index)</td></tr>
<tr class="separator:aef16f47d963dbc40901d60569efd5c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc4d370bfea2004444722daa359f2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#adfc4d370bfea2004444722daa359f2e8">SwapElements</a> (access_type const &amp;index, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token)</td></tr>
<tr class="separator:adfc4d370bfea2004444722daa359f2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840bb843eb3f0ecc2b3df2bcfcad4fb5"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a840bb843eb3f0ecc2b3df2bcfcad4fb5">begin</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) noexcept</td></tr>
<tr class="memdesc:a840bb843eb3f0ecc2b3df2bcfcad4fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator to the beginning of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a840bb843eb3f0ecc2b3df2bcfcad4fb5">More...</a><br /></td></tr>
<tr class="separator:a840bb843eb3f0ecc2b3df2bcfcad4fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80b84e3c4a3863f2591108ed560a05e"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#af80b84e3c4a3863f2591108ed560a05e">rbegin</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) noexcept</td></tr>
<tr class="memdesc:af80b84e3c4a3863f2591108ed560a05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reverse iterator to the beginning of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#af80b84e3c4a3863f2591108ed560a05e">More...</a><br /></td></tr>
<tr class="separator:af80b84e3c4a3863f2591108ed560a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b2d575ffc17514005623d5ee824344"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a27b2d575ffc17514005623d5ee824344">end</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) noexcept</td></tr>
<tr class="memdesc:a27b2d575ffc17514005623d5ee824344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator to the end of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a27b2d575ffc17514005623d5ee824344">More...</a><br /></td></tr>
<tr class="separator:a27b2d575ffc17514005623d5ee824344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6107c6b12c61152dd7a078d5a8cdba73"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a6107c6b12c61152dd7a078d5a8cdba73">rend</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) noexcept</td></tr>
<tr class="memdesc:a6107c6b12c61152dd7a078d5a8cdba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reverse iterator to the end of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a6107c6b12c61152dd7a078d5a8cdba73">More...</a><br /></td></tr>
<tr class="separator:a6107c6b12c61152dd7a078d5a8cdba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2305e3376033687913a64c56dc40ae"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#aca2305e3376033687913a64c56dc40ae">begin</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const noexcept</td></tr>
<tr class="memdesc:aca2305e3376033687913a64c56dc40ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator to the beginning of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#aca2305e3376033687913a64c56dc40ae">More...</a><br /></td></tr>
<tr class="separator:aca2305e3376033687913a64c56dc40ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc979b1518774cb45e9e417dacf0251"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a7dc979b1518774cb45e9e417dacf0251">rbegin</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const noexcept</td></tr>
<tr class="memdesc:a7dc979b1518774cb45e9e417dacf0251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reversed iterator to the beginning of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a7dc979b1518774cb45e9e417dacf0251">More...</a><br /></td></tr>
<tr class="separator:a7dc979b1518774cb45e9e417dacf0251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57854890053e43caf4fc0a3284667e4"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#af57854890053e43caf4fc0a3284667e4">end</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const noexcept</td></tr>
<tr class="memdesc:af57854890053e43caf4fc0a3284667e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator to the end of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#af57854890053e43caf4fc0a3284667e4">More...</a><br /></td></tr>
<tr class="separator:af57854890053e43caf4fc0a3284667e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921b7270a810745aaded989a88c5e1e6"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a921b7270a810745aaded989a88c5e1e6">rend</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const noexcept</td></tr>
<tr class="memdesc:a921b7270a810745aaded989a88c5e1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reverse iterator to the end of the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a921b7270a810745aaded989a88c5e1e6">More...</a><br /></td></tr>
<tr class="separator:a921b7270a810745aaded989a88c5e1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129a57f9577d87fdb996aa8fecc65b82"><td class="memItemLeft" align="right" valign="top"><a id="a129a57f9577d87fdb996aa8fecc65b82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a129a57f9577d87fdb996aa8fecc65b82">clear</a> () noexcept</td></tr>
<tr class="memdesc:a129a57f9577d87fdb996aa8fecc65b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container. <br /></td></tr>
<tr class="separator:a129a57f9577d87fdb996aa8fecc65b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425f1eb0ee2e1f6006ad9c9b96cacba5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a425f1eb0ee2e1f6006ad9c9b96cacba5">clear</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) noexcept</td></tr>
<tr class="separator:a425f1eb0ee2e1f6006ad9c9b96cacba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91cec2192a94efd3c66dc3f7e96d182"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#ae91cec2192a94efd3c66dc3f7e96d182">empty</a> () const</td></tr>
<tr class="separator:ae91cec2192a94efd3c66dc3f7e96d182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493149a792e4ada2cc6bce993baa8b48"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html#a493149a792e4ada2cc6bce993baa8b48">empty</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const=0</td></tr>
<tr class="separator:a493149a792e4ada2cc6bce993baa8b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cacc8a6d3eacc8311717e165f25742"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a73cacc8a6d3eacc8311717e165f25742">Guard</a> () const</td></tr>
<tr class="memdesc:a73cacc8a6d3eacc8311717e165f25742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a73cacc8a6d3eacc8311717e165f25742">More...</a><br /></td></tr>
<tr class="separator:a73cacc8a6d3eacc8311717e165f25742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f13bd5673fa87ccb4c770a789487d"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ad78f13bd5673fa87ccb4c770a789487d">Guard</a> (std::defer_lock_t) const noexcept</td></tr>
<tr class="memdesc:ad78f13bd5673fa87ccb4c770a789487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ad78f13bd5673fa87ccb4c770a789487d">More...</a><br /></td></tr>
<tr class="separator:ad78f13bd5673fa87ccb4c770a789487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0f0abafdf4094cec9160377c4f08bb"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ada0f0abafdf4094cec9160377c4f08bb">Guard</a> (std::try_to_lock_t) const</td></tr>
<tr class="memdesc:ada0f0abafdf4094cec9160377c4f08bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ada0f0abafdf4094cec9160377c4f08bb">More...</a><br /></td></tr>
<tr class="separator:ada0f0abafdf4094cec9160377c4f08bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf731b04882c8c3af904abfe209a2a9e"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#acf731b04882c8c3af904abfe209a2a9e">Guard</a> (std::adopt_lock_t) const</td></tr>
<tr class="memdesc:acf731b04882c8c3af904abfe209a2a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#acf731b04882c8c3af904abfe209a2a9e">More...</a><br /></td></tr>
<tr class="separator:acf731b04882c8c3af904abfe209a2a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac3312ca591b49391dbffebf6616b97"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a1ac3312ca591b49391dbffebf6616b97"><td class="memTemplItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a1ac3312ca591b49391dbffebf6616b97">Guard</a> (std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration) const</td></tr>
<tr class="memdesc:a1ac3312ca591b49391dbffebf6616b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a1ac3312ca591b49391dbffebf6616b97">More...</a><br /></td></tr>
<tr class="separator:a1ac3312ca591b49391dbffebf6616b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c5b734876b33f219ac96ae63a3cf35"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:ae5c5b734876b33f219ac96ae63a3cf35"><td class="memTemplItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ae5c5b734876b33f219ac96ae63a3cf35">Guard</a> (std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time) const</td></tr>
<tr class="memdesc:ae5c5b734876b33f219ac96ae63a3cf35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ae5c5b734876b33f219ac96ae63a3cf35">More...</a><br /></td></tr>
<tr class="separator:ae5c5b734876b33f219ac96ae63a3cf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af353a90fa3eeadbef09e3e0b2460821b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#af353a90fa3eeadbef09e3e0b2460821b">is_closed</a> () const</td></tr>
<tr class="separator:af353a90fa3eeadbef09e3e0b2460821b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ba7eb1fa06641452224fcc0ed43809"><td class="memItemLeft" align="right" valign="top"><a id="ac4ba7eb1fa06641452224fcc0ed43809"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ac4ba7eb1fa06641452224fcc0ed43809">close</a> ()</td></tr>
<tr class="memdesc:ac4ba7eb1fa06641452224fcc0ed43809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the container for modification and notifies all waiting threads. <br /></td></tr>
<tr class="separator:ac4ba7eb1fa06641452224fcc0ed43809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a517451390114e5e63ff77a2101467"><td class="memItemLeft" align="right" valign="top"><a id="a18a517451390114e5e63ff77a2101467"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a18a517451390114e5e63ff77a2101467">open</a> ()</td></tr>
<tr class="memdesc:a18a517451390114e5e63ff77a2101467"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re-) opens the queue. <br /></td></tr>
<tr class="separator:a18a517451390114e5e63ff77a2101467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91cec2192a94efd3c66dc3f7e96d182"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ae91cec2192a94efd3c66dc3f7e96d182">empty</a> () const</td></tr>
<tr class="separator:ae91cec2192a94efd3c66dc3f7e96d182"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a85f166b663629e404adc79dab92f6454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a85f166b663629e404adc79dab92f6454">CanModify</a> () const</td></tr>
<tr class="separator:a85f166b663629e404adc79dab92f6454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63f0c026734b0af084d90f6a54def5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ac63f0c026734b0af084d90f6a54def5d">CheckForOwnership</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const</td></tr>
<tr class="memdesc:ac63f0c026734b0af084d90f6a54def5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given token belongs to this class.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ac63f0c026734b0af084d90f6a54def5d">More...</a><br /></td></tr>
<tr class="separator:ac63f0c026734b0af084d90f6a54def5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a28449dcf038fb7ceeb91ae88b577b419"><td class="memItemLeft" align="right" valign="top"><a id="a28449dcf038fb7ceeb91ae88b577b419"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a28449dcf038fb7ceeb91ae88b577b419">_containerAccess</a></td></tr>
<tr class="memdesc:a28449dcf038fb7ceeb91ae88b577b419"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container mutex. <br /></td></tr>
<tr class="separator:a28449dcf038fb7ceeb91ae88b577b419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174cf6c732ca095519c2562e9d994140"><td class="memItemLeft" align="right" valign="top"><a id="a174cf6c732ca095519c2562e9d994140"></a>
std::condition_variable_any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a174cf6c732ca095519c2562e9d994140">_containerCV</a></td></tr>
<tr class="memdesc:a174cf6c732ca095519c2562e9d994140"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container condition variable used to signal changes in the container. <br /></td></tr>
<tr class="separator:a174cf6c732ca095519c2562e9d994140"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a8e8d076ed5f32bcd5ce3b87b50cdee06"><td class="memItemLeft" align="right" valign="top"><a id="a8e8d076ed5f32bcd5ce3b87b50cdee06"></a>
static constexpr const <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a> = std::chrono::hours(100)</td></tr>
<tr class="memdesc:a8e8d076ed5f32bcd5ce3b87b50cdee06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default maximum wait time for containers. <br /></td></tr>
<tr class="separator:a8e8d076ed5f32bcd5ce3b87b50cdee06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;<br />
class HORIZON::ALGORITHM::CONCURRENT::concurrent_vector&lt; T, Alloc &gt;</h3>

<p>A concurrent vector. </p>
<p>This class adds concurrent access utility and lock functionality. It acts as an interface to prevent accidental race conditions while working as a standard STL container. As with everything C/C++-related, this cannot guarantee or prevent malicious behaviour. However, this must be a conscious choice of the implementer to circumvent the safety-mechanics of the containers.</p>
<p>You will find that all methods provide two signatures: A default (stl-like) implementation and one requiring an access_token. Access_tokens are supposed to mark ownership of the container. This is useful if you need to make multiple calls to the container without interference of other threads. An access_token can be obtained by using the <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a73cacc8a6d3eacc8311717e165f25742" title="Takes ownership over the container.">Guard()</a>-methods of the container. Once a token is out of scope (or manually unlocked) the ownership is released. Each "default" method signature will acquire a guard token and then call the guarded implementation.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is by no means complete and gets extended upon need! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00030">30</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aca2305e3376033687913a64c56dc40ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2305e3376033687913a64c56dc40ae">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator to the beginning of the container. </p>
<p>Iterators are THE problem for concurrent containers. There is no guarantee that the container is owned by the thread requesting the iterator, thus resulting in race conditions. I decided to expose the underlying container iterator, but only in "locked" methods. If you need to use iterators (and lets be honest, they are pretty neat), make sure you follow this principle: </p><div class="fragment"><div class="line">{</div>
<div class="line">     <span class="keyword">auto</span> token = container.Guard();</div>
<div class="line">     <span class="keyword">auto</span> it = container.begin(token);</div>
<div class="line">     ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This ensures that the container is locked until the iterator is out of scope (curly-brackets). It is not as nice as just using the standard begin, and prevents the "default" usage of containers in stl algorithms but emphasises the need for ownership. If I feel the need for it, I'll implement a custom iterator that locks the container until it is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is inherently unsafe! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00313">313</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a840bb843eb3f0ecc2b3df2bcfcad4fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840bb843eb3f0ecc2b3df2bcfcad4fb5">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator to the beginning of the container. </p>
<p>Iterators are THE problem for concurrent containers. There is no guarantee that the container is owned by the thread requesting the iterator, thus resulting in race conditions. I decided to expose the underlying container iterator, but only in "locked" methods. If you need to use iterators (and lets be honest, they are pretty neat), make sure you follow this principle: </p><div class="fragment"><div class="line">{</div>
<div class="line">     <span class="keyword">auto</span> token = container.Guard();</div>
<div class="line">     <span class="keyword">auto</span> it = container.begin(token);</div>
<div class="line">     ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This ensures that the container is locked until the iterator is out of scope (curly-brackets). It is not as nice as just using the standard begin, and prevents the "default" usage of containers in stl algorithms but emphasises the need for ownership. If I feel the need for it, I'll implement a custom iterator that locks the container until it is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is inherently unsafe! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00271">271</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a85f166b663629e404adc79dab92f6454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f166b663629e404adc79dab92f6454">&#9670;&nbsp;</a></span>CanModify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HORIZON::ALGORITHM::CONCURRENT::concurrent_base::CanModify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the container can be modified (close token is not set). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00166">166</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="a5f325cf82ed4ac2a6b7ba0f73b1b7512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f325cf82ed4ac2a6b7ba0f73b1b7512">&#9670;&nbsp;</a></span>capacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Gets the capacity of the container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00057">57</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a001460c88a8f3512562df1ba1bb87dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001460c88a8f3512562df1ba1bb87dc7">&#9670;&nbsp;</a></span>capacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the capacity of the container if it is owned by the calling thread. </p>
<dl class="section warning"><dt>Warning</dt><dd>The calling thread must provide the corresponding access token! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00066">66</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="ac63f0c026734b0af084d90f6a54def5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63f0c026734b0af084d90f6a54def5d">&#9670;&nbsp;</a></span>CheckForOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HORIZON::ALGORITHM::CONCURRENT::concurrent_base::CheckForOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given token belongs to this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This has no effect in no-debug builds. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00176">176</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="a425f1eb0ee2e1f6006ad9c9b96cacba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425f1eb0ee2e1f6006ad9c9b96cacba5">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00359">359</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="ae91cec2192a94efd3c66dc3f7e96d182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91cec2192a94efd3c66dc3f7e96d182">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HORIZON::ALGORITHM::CONCURRENT::concurrent_base::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the container is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00114">114</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ae91cec2192a94efd3c66dc3f7e96d182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91cec2192a94efd3c66dc3f7e96d182">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HORIZON::ALGORITHM::CONCURRENT::concurrent_base::empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the container is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00114">114</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="a3153e8a8613f4af6a1b5d094cc748364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3153e8a8613f4af6a1b5d094cc748364">&#9670;&nbsp;</a></span>empty() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the container is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token marking the ownership of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the container is empty. </dd></dl>

<p>Implements <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a0a01af282cda58a405d63978b634d946">HORIZON::ALGORITHM::CONCURRENT::concurrent_base</a>.</p>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00092">92</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a493149a792e4ada2cc6bce993baa8b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493149a792e4ada2cc6bce993baa8b48">&#9670;&nbsp;</a></span>empty() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HORIZON::ALGORITHM::CONCURRENT::concurrent_base::empty</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the container is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token marking the ownership of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the container is empty. </dd></dl>

</div>
</div>
<a id="af57854890053e43caf4fc0a3284667e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57854890053e43caf4fc0a3284667e4">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator to the end of the container. </p>
<p>Iterators are THE problem for concurrent containers. There is no guarantee that the container is owned by the thread requesting the iterator, thus resulting in race conditions. I decided to expose the underlying container iterator, but only in "locked" methods. If you need to use iterators (and lets be honest, they are pretty neat), make sure you follow this principle: </p><div class="fragment"><div class="line">{</div>
<div class="line">     <span class="keyword">auto</span> token = container.Guard();</div>
<div class="line">     <span class="keyword">auto</span> it = container.begin(token);</div>
<div class="line">     ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This ensures that the container is locked until the iterator is out of scope (curly-brackets). It is not as nice as just using the standard begin, and prevents the "default" usage of containers in stl algorithms but emphasises the need for ownership. If I feel the need for it, I'll implement a custom iterator that locks the container until it is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is inherently unsafe! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00333">333</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a27b2d575ffc17514005623d5ee824344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b2d575ffc17514005623d5ee824344">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator to the end of the container. </p>
<p>Iterators are THE problem for concurrent containers. There is no guarantee that the container is owned by the thread requesting the iterator, thus resulting in race conditions. I decided to expose the underlying container iterator, but only in "locked" methods. If you need to use iterators (and lets be honest, they are pretty neat), make sure you follow this principle: </p><div class="fragment"><div class="line">{</div>
<div class="line">     <span class="keyword">auto</span> token = container.Guard();</div>
<div class="line">     <span class="keyword">auto</span> it = container.begin(token);</div>
<div class="line">     ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This ensures that the container is locked until the iterator is out of scope (curly-brackets). It is not as nice as just using the standard begin, and prevents the "default" usage of containers in stl algorithms but emphasises the need for ownership. If I feel the need for it, I'll implement a custom iterator that locks the container until it is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is inherently unsafe! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00292">292</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a73cacc8a6d3eacc8311717e165f25742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cacc8a6d3eacc8311717e165f25742">&#9670;&nbsp;</a></span>Guard() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="acf731b04882c8c3af904abfe209a2a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf731b04882c8c3af904abfe209a2a9e">&#9670;&nbsp;</a></span>Guard() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::adopt_lock_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="a1ac3312ca591b49391dbffebf6616b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac3312ca591b49391dbffebf6616b97">&#9670;&nbsp;</a></span>Guard() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt; const &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ae5c5b734876b33f219ac96ae63a3cf35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c5b734876b33f219ac96ae63a3cf35">&#9670;&nbsp;</a></span>Guard() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; Clock, Duration &gt; const &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ad78f13bd5673fa87ccb4c770a789487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f13bd5673fa87ccb4c770a789487d">&#9670;&nbsp;</a></span>Guard() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::defer_lock_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ada0f0abafdf4094cec9160377c4f08bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0f0abafdf4094cec9160377c4f08bb">&#9670;&nbsp;</a></span>Guard() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::try_to_lock_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="af353a90fa3eeadbef09e3e0b2460821b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af353a90fa3eeadbef09e3e0b2460821b">&#9670;&nbsp;</a></span>is_closed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HORIZON::ALGORITHM::CONCURRENT::concurrent_base::is_closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the container is closed (elements cannot be modified). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00086">86</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ae4b78f7d6d4e94a9c01fb5c2f19b6c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b78f7d6d4e94a9c01fb5c2f19b6c61">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inplace creates the given element at the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00178">178</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="adac1708467102268ce05f9e27052fc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac1708467102268ce05f9e27052fc8f">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inplace creates the given element at the end of the vector if the container is owned by the calling thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add. </td></tr>
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00186">186</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a3b543d8d5bbcb0f285014615e9fc865d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b543d8d5bbcb0f285014615e9fc865d">&#9670;&nbsp;</a></span>push_back() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places the given element at the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The element to add. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00159">159</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a718608315bbe36aff295618a23cb67bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718608315bbe36aff295618a23cb67bb">&#9670;&nbsp;</a></span>push_back() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places the given element at the end of the vector if the vector is owned by the calling thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add. </td></tr>
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00167">167</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a7dc979b1518774cb45e9e417dacf0251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc979b1518774cb45e9e417dacf0251">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reversed iterator to the beginning of the container. </p>
<p>Iterators are THE problem for concurrent containers. There is no guarantee that the container is owned by the thread requesting the iterator, thus resulting in race conditions. I decided to expose the underlying container iterator, but only in "locked" methods. If you need to use iterators (and lets be honest, they are pretty neat), make sure you follow this principle: </p><div class="fragment"><div class="line">{</div>
<div class="line">     <span class="keyword">auto</span> token = container.Guard();</div>
<div class="line">     <span class="keyword">auto</span> it = container.begin(token);</div>
<div class="line">     ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This ensures that the container is locked until the iterator is out of scope (curly-brackets). It is not as nice as just using the standard begin, and prevents the "default" usage of containers in stl algorithms but emphasises the need for ownership. If I feel the need for it, I'll implement a custom iterator that locks the container until it is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is inherently unsafe! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00323">323</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="af80b84e3c4a3863f2591108ed560a05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80b84e3c4a3863f2591108ed560a05e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reverse iterator to the beginning of the container. </p>
<p>Iterators are THE problem for concurrent containers. There is no guarantee that the container is owned by the thread requesting the iterator, thus resulting in race conditions. I decided to expose the underlying container iterator, but only in "locked" methods. If you need to use iterators (and lets be honest, they are pretty neat), make sure you follow this principle: </p><div class="fragment"><div class="line">{</div>
<div class="line">     <span class="keyword">auto</span> token = container.Guard();</div>
<div class="line">     <span class="keyword">auto</span> it = container.begin(token);</div>
<div class="line">     ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This ensures that the container is locked until the iterator is out of scope (curly-brackets). It is not as nice as just using the standard begin, and prevents the "default" usage of containers in stl algorithms but emphasises the need for ownership. If I feel the need for it, I'll implement a custom iterator that locks the container until it is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is inherently unsafe! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00282">282</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a921b7270a810745aaded989a88c5e1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921b7270a810745aaded989a88c5e1e6">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reverse iterator to the end of the container. </p>
<p>Iterators are THE problem for concurrent containers. There is no guarantee that the container is owned by the thread requesting the iterator, thus resulting in race conditions. I decided to expose the underlying container iterator, but only in "locked" methods. If you need to use iterators (and lets be honest, they are pretty neat), make sure you follow this principle: </p><div class="fragment"><div class="line">{</div>
<div class="line">     <span class="keyword">auto</span> token = container.Guard();</div>
<div class="line">     <span class="keyword">auto</span> it = container.begin(token);</div>
<div class="line">     ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This ensures that the container is locked until the iterator is out of scope (curly-brackets). It is not as nice as just using the standard begin, and prevents the "default" usage of containers in stl algorithms but emphasises the need for ownership. If I feel the need for it, I'll implement a custom iterator that locks the container until it is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is inherently unsafe! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00343">343</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a6107c6b12c61152dd7a078d5a8cdba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6107c6b12c61152dd7a078d5a8cdba73">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reverse iterator to the end of the container. </p>
<p>Iterators are THE problem for concurrent containers. There is no guarantee that the container is owned by the thread requesting the iterator, thus resulting in race conditions. I decided to expose the underlying container iterator, but only in "locked" methods. If you need to use iterators (and lets be honest, they are pretty neat), make sure you follow this principle: </p><div class="fragment"><div class="line">{</div>
<div class="line">     <span class="keyword">auto</span> token = container.Guard();</div>
<div class="line">     <span class="keyword">auto</span> it = container.begin(token);</div>
<div class="line">     ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This ensures that the container is locked until the iterator is out of scope (curly-brackets). It is not as nice as just using the standard begin, and prevents the "default" usage of containers in stl algorithms but emphasises the need for ownership. If I feel the need for it, I'll implement a custom iterator that locks the container until it is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is inherently unsafe! </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00302">302</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="ab7ae63c9ffbe2ea67ece0521a027072f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ae63c9ffbe2ea67ece0521a027072f">&#9670;&nbsp;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space in the container without initialising. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new capacity of the container. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00141">141</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a3ffd6ddb2b07bf64e55f83fc866b464e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffd6ddb2b07bf64e55f83fc866b464e">&#9670;&nbsp;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space in the container without initialising. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new capacity of the container. </td></tr>
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00149">149</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a2c6cb87faa9de996dbdb4f950a7cf0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6cb87faa9de996dbdb4f950a7cf0c7">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container if it is owned by the calling thread. </p>
<dl class="section warning"><dt>Warning</dt><dd>The calling thread must provide the corresponding access token! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size of the container. </td></tr>
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00111">111</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a6672ece8fd1f6045feeb51112f1b5fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6672ece8fd1f6045feeb51112f1b5fd0">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container and initialises with a default element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size of the container. </td></tr>
    <tr><td class="paramname">def</td><td>The default value of the container. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00122">122</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="adc71b02801922dd66ac846c5c6ed5e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc71b02801922dd66ac846c5c6ed5e23">&#9670;&nbsp;</a></span>resize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container and initialises with a default element if it is owned by the calling thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size of the container. </td></tr>
    <tr><td class="paramname">def</td><td>The default value of the container. </td></tr>
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00131">131</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a99b1f7fb4eb5e9474eaf03877d86af79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b1f7fb4eb5e9474eaf03877d86af79">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Gets the size of the container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00075">75</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a3322b1514deeb3e97b6cbdbacc87a11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3322b1514deeb3e97b6cbdbacc87a11b">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of hte container if it is owned by the calling thread. </p>
<dl class="section warning"><dt>Warning</dt><dd>The calling thread must provide the corresponding access token! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00084">84</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="a16feb021870b68236ed0797b853f1358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16feb021870b68236ed0797b853f1358">&#9670;&nbsp;</a></span>SwapElements() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::SwapElements </td>
          <td>(</td>
          <td class="paramtype">access_type const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">access_type const &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two elements of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The index of the first element. </td></tr>
    <tr><td class="paramname">second</td><td>THe index of the second element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If either first or second is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00200">200</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="ab1507213297533ff8605803be7b89182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1507213297533ff8605803be7b89182">&#9670;&nbsp;</a></span>SwapElements() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::SwapElements </td>
          <td>(</td>
          <td class="paramtype">access_type const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">access_type const &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two elements of the container if the container is owned by the calling thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The index of the first element. </td></tr>
    <tr><td class="paramname">second</td><td>The index of the second element. </td></tr>
    <tr><td class="paramname">token</td><td>The access token.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If either first or second is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00211">211</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="aef16f47d963dbc40901d60569efd5c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef16f47d963dbc40901d60569efd5c7e">&#9670;&nbsp;</a></span>SwapElements() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::SwapElements </td>
          <td>(</td>
          <td class="paramtype">access_type const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps the given element with the last element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If <code>index</code> is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00230">230</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<a id="adfc4d370bfea2004444722daa359f2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc4d370bfea2004444722daa359f2e8">&#9670;&nbsp;</a></span>SwapElements() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_vector</a>&lt; T, Alloc &gt;::SwapElements </td>
          <td>(</td>
          <td class="paramtype">access_type const &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps the given element with the last element if the container is owned by the calling thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element. </td></tr>
    <tr><td class="paramname">token</td><td>The access token.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If <code>index</code> is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__vector_8hpp_source.html#l00241">241</a> of file <a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="concurrent__vector_8hpp_source.html">concurrent_vector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_h_o_r_i_z_o_n.html">HORIZON</a></li><li class="navelem"><a class="el" href="namespace_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m.html">ALGORITHM</a></li><li class="navelem"><a class="el" href="namespace_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t.html">CONCURRENT</a></li><li class="navelem"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__vector.html">concurrent_vector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
