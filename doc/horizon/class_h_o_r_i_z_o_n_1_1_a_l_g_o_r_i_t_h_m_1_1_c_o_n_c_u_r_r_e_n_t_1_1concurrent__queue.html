<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Horizon: HORIZON::ALGORITHM::CONCURRENT::concurrent_queue&lt; T, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Horizon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue&lt; T, Container &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group__horizon.html">Horizon</a> &raquo; <a class="el" href="group__group__module__algorithm.html">Algorithm</a> &raquo; <a class="el" href="group__group__algorithm__concurrent.html">Concurrent</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A concurrent queue.  
 <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_base</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a42c5dc5fdd27a44613833bffcb0147ad"><td class="memItemLeft" align="right" valign="top"><a id="a42c5dc5fdd27a44613833bffcb0147ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> = typename Container::value_type</td></tr>
<tr class="memdesc:a42c5dc5fdd27a44613833bffcb0147ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the items stored in the container. <br /></td></tr>
<tr class="separator:a42c5dc5fdd27a44613833bffcb0147ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845033ca467ff3d33c6da81fc9c5c911"><td class="memItemLeft" align="right" valign="top"><a id="a845033ca467ff3d33c6da81fc9c5c911"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = typename Container::reference</td></tr>
<tr class="separator:a845033ca467ff3d33c6da81fc9c5c911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ec2140ce2ba31151905c0e28adb60a"><td class="memItemLeft" align="right" valign="top"><a id="a78ec2140ce2ba31151905c0e28adb60a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = typename Container::const_reference</td></tr>
<tr class="separator:a78ec2140ce2ba31151905c0e28adb60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2fe29487c052c220fe02651af2b1ef"><td class="memItemLeft" align="right" valign="top"><a id="a6a2fe29487c052c220fe02651af2b1ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename Container::size_type</td></tr>
<tr class="separator:a6a2fe29487c052c220fe02651af2b1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae625a3730becd23c8478a50cc1b1baab"><td class="memItemLeft" align="right" valign="top"><a id="ae625a3730becd23c8478a50cc1b1baab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>container_type</b> = std::queue&lt; <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a>, Container &gt;</td></tr>
<tr class="separator:ae625a3730becd23c8478a50cc1b1baab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d82b4bcf23db039e00e34a1438e4576"><td class="memItemLeft" align="right" valign="top"><a id="a5d82b4bcf23db039e00e34a1438e4576"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> = std::unique_lock&lt; std::mutex &gt;</td></tr>
<tr class="memdesc:a5d82b4bcf23db039e00e34a1438e4576"><td class="mdescLeft">&#160;</td><td class="mdescRight">The access token type used to mark ownership. <br /></td></tr>
<tr class="separator:a5d82b4bcf23db039e00e34a1438e4576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5fcaac1309122018e9257f59ddad32"><td class="memItemLeft" align="right" valign="top"><a id="a6c5fcaac1309122018e9257f59ddad32"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> = std::chrono::nanoseconds</td></tr>
<tr class="memdesc:a6c5fcaac1309122018e9257f59ddad32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time type used for timeouts. <br /></td></tr>
<tr class="separator:a6c5fcaac1309122018e9257f59ddad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:addf088506d97f5bd48485fc9c6c7f374"><td class="memItemLeft" align="right" valign="top"><a id="addf088506d97f5bd48485fc9c6c7f374"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#addf088506d97f5bd48485fc9c6c7f374">concurrent_queue</a> ()</td></tr>
<tr class="memdesc:addf088506d97f5bd48485fc9c6c7f374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new, empty concurrent queue. <br /></td></tr>
<tr class="separator:addf088506d97f5bd48485fc9c6c7f374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3fb0343d5659078f8832e8637dc235"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a1a3fb0343d5659078f8832e8637dc235">concurrent_queue</a> (Container const &amp;container)</td></tr>
<tr class="memdesc:a1a3fb0343d5659078f8832e8637dc235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a concurrent queue from an existing queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a1a3fb0343d5659078f8832e8637dc235">More...</a><br /></td></tr>
<tr class="separator:a1a3fb0343d5659078f8832e8637dc235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c2c44bfc6cffb04d048fb32b24eed8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#af9c2c44bfc6cffb04d048fb32b24eed8">concurrent_queue</a> (Container &amp;&amp;container)</td></tr>
<tr class="memdesc:af9c2c44bfc6cffb04d048fb32b24eed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a concurrent queue from an existing queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#af9c2c44bfc6cffb04d048fb32b24eed8">More...</a><br /></td></tr>
<tr class="separator:af9c2c44bfc6cffb04d048fb32b24eed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40a2c9e4276ff5017a2a0c1c6b19cb8"><td class="memItemLeft" align="right" valign="top"><a id="ae40a2c9e4276ff5017a2a0c1c6b19cb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ae40a2c9e4276ff5017a2a0c1c6b19cb8">~concurrent_queue</a> ()</td></tr>
<tr class="memdesc:ae40a2c9e4276ff5017a2a0c1c6b19cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the queue and destroys the concurrent queue object. <br /></td></tr>
<tr class="separator:ae40a2c9e4276ff5017a2a0c1c6b19cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbe0b471a0ab4dc1834e4731c934611"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#aedbe0b471a0ab4dc1834e4731c934611">empty</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const override</td></tr>
<tr class="separator:aedbe0b471a0ab4dc1834e4731c934611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d0d18ccbf28c160b6dc67db6d5148c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a70d0d18ccbf28c160b6dc67db6d5148c">size</a> () const</td></tr>
<tr class="separator:a70d0d18ccbf28c160b6dc67db6d5148c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646b158ea2b71092746db61974cfb94a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a646b158ea2b71092746db61974cfb94a">size</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const</td></tr>
<tr class="separator:a646b158ea2b71092746db61974cfb94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71797322561c63ba4aeb434a37a3efd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a71797322561c63ba4aeb434a37a3efd6">push</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> const &amp;item) noexcept</td></tr>
<tr class="memdesc:a71797322561c63ba4aeb434a37a3efd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a71797322561c63ba4aeb434a37a3efd6">More...</a><br /></td></tr>
<tr class="separator:a71797322561c63ba4aeb434a37a3efd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751eeaef9f400ce23f0b256e0e52fd28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a751eeaef9f400ce23f0b256e0e52fd28">push</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> &amp;&amp;item) noexcept</td></tr>
<tr class="memdesc:a751eeaef9f400ce23f0b256e0e52fd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the queue. noexcept  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a751eeaef9f400ce23f0b256e0e52fd28">More...</a><br /></td></tr>
<tr class="separator:a751eeaef9f400ce23f0b256e0e52fd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eac66a1389b2415e962808db05498a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ae6eac66a1389b2415e962808db05498a">push</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> const &amp;item, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) noexcept</td></tr>
<tr class="memdesc:ae6eac66a1389b2415e962808db05498a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the end of the queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ae6eac66a1389b2415e962808db05498a">More...</a><br /></td></tr>
<tr class="separator:ae6eac66a1389b2415e962808db05498a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad251ba6b8fe49efb05c0da02e2981365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ad251ba6b8fe49efb05c0da02e2981365">push</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> &amp;&amp;item, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) noexcept</td></tr>
<tr class="memdesc:ad251ba6b8fe49efb05c0da02e2981365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the end of the queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ad251ba6b8fe49efb05c0da02e2981365">More...</a><br /></td></tr>
<tr class="separator:ad251ba6b8fe49efb05c0da02e2981365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2550ce93cf94917dbfb38aa54dee3de"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:af2550ce93cf94917dbfb38aa54dee3de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#af2550ce93cf94917dbfb38aa54dee3de">emplace</a> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:af2550ce93cf94917dbfb38aa54dee3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in place at the end of the queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#af2550ce93cf94917dbfb38aa54dee3de">More...</a><br /></td></tr>
<tr class="separator:af2550ce93cf94917dbfb38aa54dee3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2cd3e62c7f314c1da2e2c1809b674a"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a5b2cd3e62c7f314c1da2e2c1809b674a"><td class="memTemplItemLeft" align="right" valign="top">reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a5b2cd3e62c7f314c1da2e2c1809b674a">emplace</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:a5b2cd3e62c7f314c1da2e2c1809b674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in place at the end of the queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a5b2cd3e62c7f314c1da2e2c1809b674a">More...</a><br /></td></tr>
<tr class="separator:a5b2cd3e62c7f314c1da2e2c1809b674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a61a79a1797bbed734bf260fe0ad8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ab5a61a79a1797bbed734bf260fe0ad8b">try_pop</a> (T &amp;item)</td></tr>
<tr class="memdesc:ab5a61a79a1797bbed734bf260fe0ad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to remove the first element.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ab5a61a79a1797bbed734bf260fe0ad8b">More...</a><br /></td></tr>
<tr class="separator:ab5a61a79a1797bbed734bf260fe0ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c3ce6d2656d2e6d7600d259ac8b111"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a98c3ce6d2656d2e6d7600d259ac8b111">try_pop</a> (T &amp;item, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> &amp;&amp;token)</td></tr>
<tr class="memdesc:a98c3ce6d2656d2e6d7600d259ac8b111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to remove the first element.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a98c3ce6d2656d2e6d7600d259ac8b111">More...</a><br /></td></tr>
<tr class="separator:a98c3ce6d2656d2e6d7600d259ac8b111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68151d491d4c41cfa56ae4ceb88214e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a68151d491d4c41cfa56ae4ceb88214e3">pop</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> const &amp;maximumWaitTime=<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a>) noexcept</td></tr>
<tr class="memdesc:a68151d491d4c41cfa56ae4ceb88214e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a68151d491d4c41cfa56ae4ceb88214e3">More...</a><br /></td></tr>
<tr class="separator:a68151d491d4c41cfa56ae4ceb88214e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7918bb6b2a3816060795486fec43ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#aa7918bb6b2a3816060795486fec43ac3">pop</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> &amp;token, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> const &amp;maximumWaitTime=<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a>) noexcept</td></tr>
<tr class="memdesc:aa7918bb6b2a3816060795486fec43ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#aa7918bb6b2a3816060795486fec43ac3">More...</a><br /></td></tr>
<tr class="separator:aa7918bb6b2a3816060795486fec43ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af420bcee8abbebfdbc8aa8f1a76b280a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#af420bcee8abbebfdbc8aa8f1a76b280a">pop</a> (T &amp;item, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> const &amp;maximumWaitTime=<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a>) noexcept</td></tr>
<tr class="memdesc:af420bcee8abbebfdbc8aa8f1a76b280a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#af420bcee8abbebfdbc8aa8f1a76b280a">More...</a><br /></td></tr>
<tr class="separator:af420bcee8abbebfdbc8aa8f1a76b280a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e4b25cd4c24bf2f9681ba38fa8b04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a996e4b25cd4c24bf2f9681ba38fa8b04">pop</a> (T &amp;item, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> &amp;&amp;token, <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> const &amp;maximumWaitTime=<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a>) noexcept</td></tr>
<tr class="separator:a996e4b25cd4c24bf2f9681ba38fa8b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e44e469960b8638efe5289857d75170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a5e44e469960b8638efe5289857d75170">clear</a> () noexcept</td></tr>
<tr class="memdesc:a5e44e469960b8638efe5289857d75170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a5e44e469960b8638efe5289857d75170">More...</a><br /></td></tr>
<tr class="separator:a5e44e469960b8638efe5289857d75170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa6ea823f5b43f80f20ed1a304f034b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a7aa6ea823f5b43f80f20ed1a304f034b">clear</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) noexcept</td></tr>
<tr class="memdesc:a7aa6ea823f5b43f80f20ed1a304f034b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a7aa6ea823f5b43f80f20ed1a304f034b">More...</a><br /></td></tr>
<tr class="separator:a7aa6ea823f5b43f80f20ed1a304f034b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cacc8a6d3eacc8311717e165f25742"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a73cacc8a6d3eacc8311717e165f25742">Guard</a> () const</td></tr>
<tr class="memdesc:a73cacc8a6d3eacc8311717e165f25742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a73cacc8a6d3eacc8311717e165f25742">More...</a><br /></td></tr>
<tr class="separator:a73cacc8a6d3eacc8311717e165f25742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f13bd5673fa87ccb4c770a789487d"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ad78f13bd5673fa87ccb4c770a789487d">Guard</a> (std::defer_lock_t) const noexcept</td></tr>
<tr class="memdesc:ad78f13bd5673fa87ccb4c770a789487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ad78f13bd5673fa87ccb4c770a789487d">More...</a><br /></td></tr>
<tr class="separator:ad78f13bd5673fa87ccb4c770a789487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0f0abafdf4094cec9160377c4f08bb"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ada0f0abafdf4094cec9160377c4f08bb">Guard</a> (std::try_to_lock_t) const</td></tr>
<tr class="memdesc:ada0f0abafdf4094cec9160377c4f08bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ada0f0abafdf4094cec9160377c4f08bb">More...</a><br /></td></tr>
<tr class="separator:ada0f0abafdf4094cec9160377c4f08bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf731b04882c8c3af904abfe209a2a9e"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#acf731b04882c8c3af904abfe209a2a9e">Guard</a> (std::adopt_lock_t) const</td></tr>
<tr class="memdesc:acf731b04882c8c3af904abfe209a2a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#acf731b04882c8c3af904abfe209a2a9e">More...</a><br /></td></tr>
<tr class="separator:acf731b04882c8c3af904abfe209a2a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac3312ca591b49391dbffebf6616b97"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a1ac3312ca591b49391dbffebf6616b97"><td class="memTemplItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a1ac3312ca591b49391dbffebf6616b97">Guard</a> (std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration) const</td></tr>
<tr class="memdesc:a1ac3312ca591b49391dbffebf6616b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a1ac3312ca591b49391dbffebf6616b97">More...</a><br /></td></tr>
<tr class="separator:a1ac3312ca591b49391dbffebf6616b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c5b734876b33f219ac96ae63a3cf35"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:ae5c5b734876b33f219ac96ae63a3cf35"><td class="memTemplItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ae5c5b734876b33f219ac96ae63a3cf35">Guard</a> (std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time) const</td></tr>
<tr class="memdesc:ae5c5b734876b33f219ac96ae63a3cf35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership over the container.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ae5c5b734876b33f219ac96ae63a3cf35">More...</a><br /></td></tr>
<tr class="separator:ae5c5b734876b33f219ac96ae63a3cf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af353a90fa3eeadbef09e3e0b2460821b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#af353a90fa3eeadbef09e3e0b2460821b">is_closed</a> () const</td></tr>
<tr class="separator:af353a90fa3eeadbef09e3e0b2460821b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ba7eb1fa06641452224fcc0ed43809"><td class="memItemLeft" align="right" valign="top"><a id="ac4ba7eb1fa06641452224fcc0ed43809"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ac4ba7eb1fa06641452224fcc0ed43809">close</a> ()</td></tr>
<tr class="memdesc:ac4ba7eb1fa06641452224fcc0ed43809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the container for modification and notifies all waiting threads. <br /></td></tr>
<tr class="separator:ac4ba7eb1fa06641452224fcc0ed43809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a517451390114e5e63ff77a2101467"><td class="memItemLeft" align="right" valign="top"><a id="a18a517451390114e5e63ff77a2101467"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a18a517451390114e5e63ff77a2101467">open</a> ()</td></tr>
<tr class="memdesc:a18a517451390114e5e63ff77a2101467"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re-) opens the queue. <br /></td></tr>
<tr class="separator:a18a517451390114e5e63ff77a2101467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91cec2192a94efd3c66dc3f7e96d182"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ae91cec2192a94efd3c66dc3f7e96d182">empty</a> () const</td></tr>
<tr class="separator:ae91cec2192a94efd3c66dc3f7e96d182"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a85f166b663629e404adc79dab92f6454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a85f166b663629e404adc79dab92f6454">CanModify</a> () const</td></tr>
<tr class="separator:a85f166b663629e404adc79dab92f6454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63f0c026734b0af084d90f6a54def5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ac63f0c026734b0af084d90f6a54def5d">CheckForOwnership</a> (<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;token) const</td></tr>
<tr class="memdesc:ac63f0c026734b0af084d90f6a54def5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given token belongs to this class.  <a href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#ac63f0c026734b0af084d90f6a54def5d">More...</a><br /></td></tr>
<tr class="separator:ac63f0c026734b0af084d90f6a54def5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a28449dcf038fb7ceeb91ae88b577b419"><td class="memItemLeft" align="right" valign="top"><a id="a28449dcf038fb7ceeb91ae88b577b419"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a28449dcf038fb7ceeb91ae88b577b419">_containerAccess</a></td></tr>
<tr class="memdesc:a28449dcf038fb7ceeb91ae88b577b419"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container mutex. <br /></td></tr>
<tr class="separator:a28449dcf038fb7ceeb91ae88b577b419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174cf6c732ca095519c2562e9d994140"><td class="memItemLeft" align="right" valign="top"><a id="a174cf6c732ca095519c2562e9d994140"></a>
std::condition_variable_any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a174cf6c732ca095519c2562e9d994140">_containerCV</a></td></tr>
<tr class="memdesc:a174cf6c732ca095519c2562e9d994140"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container condition variable used to signal changes in the container. <br /></td></tr>
<tr class="separator:a174cf6c732ca095519c2562e9d994140"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a8e8d076ed5f32bcd5ce3b87b50cdee06"><td class="memItemLeft" align="right" valign="top"><a id="a8e8d076ed5f32bcd5ce3b87b50cdee06"></a>
static constexpr const <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a> = std::chrono::hours(100)</td></tr>
<tr class="memdesc:a8e8d076ed5f32bcd5ce3b87b50cdee06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default maximum wait time for containers. <br /></td></tr>
<tr class="separator:a8e8d076ed5f32bcd5ce3b87b50cdee06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt;<br />
class HORIZON::ALGORITHM::CONCURRENT::concurrent_queue&lt; T, Container &gt;</h3>

<p>A concurrent queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname">Container</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This implementation is by no means complete and may/will expand upon my need. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00030">30</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a3fb0343d5659078f8832e8637dc235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3fb0343d5659078f8832e8637dc235">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a concurrent queue from an existing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00056">56</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="af9c2c44bfc6cffb04d048fb32b24eed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c2c44bfc6cffb04d048fb32b24eed8">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::<a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a concurrent queue from an existing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00064">64</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85f166b663629e404adc79dab92f6454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f166b663629e404adc79dab92f6454">&#9670;&nbsp;</a></span>CanModify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HORIZON::ALGORITHM::CONCURRENT::concurrent_base::CanModify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the container can be modified (close token is not set). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00166">166</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ac63f0c026734b0af084d90f6a54def5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63f0c026734b0af084d90f6a54def5d">&#9670;&nbsp;</a></span>CheckForOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HORIZON::ALGORITHM::CONCURRENT::concurrent_base::CheckForOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given token belongs to this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This has no effect in no-debug builds. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00176">176</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="a5e44e469960b8638efe5289857d75170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e44e469960b8638efe5289857d75170">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the queue. </p>
<dl class="section note"><dt>Note</dt><dd>Calling this method takes ownership of the container for the duration of the clear. If the container is currently owned by another thread, this method will block until the other thread releases the container.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a7aa6ea823f5b43f80f20ed1a304f034b" title="Clears the queue.">clear(access_token const&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00339">339</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a7aa6ea823f5b43f80f20ed1a304f034b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa6ea823f5b43f80f20ed1a304f034b">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the queue. </p>
<p>Calling this method requires the caller to provide an ownership token of the corresponding queue object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token of this queue. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00347">347</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a5b2cd3e62c7f314c1da2e2c1809b674a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2cd3e62c7f314c1da2e2c1809b674a">&#9670;&nbsp;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in place at the end of the queue. </p>
<p>Calling this method requires the caller to provide an ownership token of the corresponding container object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token of this queue. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to create an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>I decided to keep this signature since it closely models the behaviour of the stl-queue. Accessing or modifying the reference after releasing ownership is technically possible but will result in undefined behaviour (and probably race conditions!)s </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00190">190</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="af2550ce93cf94917dbfb38aa54dee3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2550ce93cf94917dbfb38aa54dee3de">&#9670;&nbsp;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in place at the end of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to create an element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The stl-queue returns a reference to the newly created item. However, it is not good practice to pass references to elements in concurrent containers. Thus, I decided against returning a reference here. The locked overload of this method however does provide the reference.</dd>
<dd>
Calling this method takes ownership of the container for the duration of the emplace. If the container is currently owned by another thread, this method will block until the other thread releases the container.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>emplace(access_token const&amp;, Args&amp;&amp; ...) </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00173">173</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="ae91cec2192a94efd3c66dc3f7e96d182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91cec2192a94efd3c66dc3f7e96d182">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HORIZON::ALGORITHM::CONCURRENT::concurrent_base::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the container is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00114">114</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="aedbe0b471a0ab4dc1834e4731c934611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbe0b471a0ab4dc1834e4731c934611">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the container is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token marking the ownership of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the container is empty. </dd></dl>

<p>Implements <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a0a01af282cda58a405d63978b634d946">HORIZON::ALGORITHM::CONCURRENT::concurrent_base</a>.</p>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00077">77</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a73cacc8a6d3eacc8311717e165f25742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cacc8a6d3eacc8311717e165f25742">&#9670;&nbsp;</a></span>Guard() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="acf731b04882c8c3af904abfe209a2a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf731b04882c8c3af904abfe209a2a9e">&#9670;&nbsp;</a></span>Guard() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::adopt_lock_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="a1ac3312ca591b49391dbffebf6616b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac3312ca591b49391dbffebf6616b97">&#9670;&nbsp;</a></span>Guard() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt; const &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ae5c5b734876b33f219ac96ae63a3cf35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c5b734876b33f219ac96ae63a3cf35">&#9670;&nbsp;</a></span>Guard() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; Clock, Duration &gt; const &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ad78f13bd5673fa87ccb4c770a789487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f13bd5673fa87ccb4c770a789487d">&#9670;&nbsp;</a></span>Guard() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::defer_lock_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="ada0f0abafdf4094cec9160377c4f08bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0f0abafdf4094cec9160377c4f08bb">&#9670;&nbsp;</a></span>Guard() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_lock&lt;std::mutex&gt; HORIZON::ALGORITHM::CONCURRENT::concurrent_base::Guard </td>
          <td>(</td>
          <td class="paramtype">std::try_to_lock_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership over the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The ownership token (an unique lock). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00080">80</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="af353a90fa3eeadbef09e3e0b2460821b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af353a90fa3eeadbef09e3e0b2460821b">&#9670;&nbsp;</a></span>is_closed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HORIZON::ALGORITHM::CONCURRENT::concurrent_base::is_closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the container is closed (elements cannot be modified). </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__base_8hpp_source.html#l00086">86</a> of file <a class="el" href="concurrent__base_8hpp_source.html">concurrent_base.hpp</a>.</p>

</div>
</div>
<a id="aa7918bb6b2a3816060795486fec43ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7918bb6b2a3816060795486fec43ac3">&#9670;&nbsp;</a></span>pop() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>maximumWaitTime</em> = <code><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element. </p>
<p>The calling thread is blocked until an element can be retrieved or until a user specified timeout is reached. If the timeout is reached, no element is removed and this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token of this queue. </td></tr>
    <tr><td class="paramname">maximumWaitTime</td><td>The maximum time to wait until the pop operation is aborted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the element could be removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00242">242</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a996e4b25cd4c24bf2f9681ba38fa8b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996e4b25cd4c24bf2f9681ba38fa8b04">&#9670;&nbsp;</a></span>pop() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>maximumWaitTime</em> = <code><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The access token of this queue. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00270">270</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="af420bcee8abbebfdbc8aa8f1a76b280a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af420bcee8abbebfdbc8aa8f1a76b280a">&#9670;&nbsp;</a></span>pop() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>maximumWaitTime</em> = <code><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element. </p>
<p>The calling thread is blocked until an element can be retrieved or until a user specified timeout is reached. If the timeout is reached, no element is removed and this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The removed element. </td></tr>
    <tr><td class="paramname">maximumWaitTime</td><td>The maximum time to wait until the pop operations is aborted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an element could be removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00261">261</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a68151d491d4c41cfa56ae4ceb88214e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68151d491d4c41cfa56ae4ceb88214e3">&#9670;&nbsp;</a></span>pop() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a6c5fcaac1309122018e9257f59ddad32">time_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>maximumWaitTime</em> = <code><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a8e8d076ed5f32bcd5ce3b87b50cdee06">_maxWaitTime</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element. </p>
<p>The calling thread is blocked until an element can be retrieved or until a user specified timeout is reached. If the timeout is reached, no element is removed and this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maximumWaitTime</td><td>The maximum time to wait until the pop operations is aborted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an element could be removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00228">228</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a751eeaef9f400ce23f0b256e0e52fd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751eeaef9f400ce23f0b256e0e52fd28">&#9670;&nbsp;</a></span>push() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the queue. noexcept </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this method takes ownership of the container for the duration of the push. If the container is currently owned by another thread, this method will block until the other thread releases the container. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ae6eac66a1389b2415e962808db05498a" title="Adds an item to the end of the queue.">push(value_type const&amp;, access_token const&amp;)</a></dd></dl>
<p>This is a typical queue operation. The function creates an element at the end of the queue and assigns the given data to it. The time complexity of the operation depends on the underlying sequence. noexcept </p>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00118">118</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="ad251ba6b8fe49efb05c0da02e2981365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad251ba6b8fe49efb05c0da02e2981365">&#9670;&nbsp;</a></span>push() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an item to the end of the queue. </p>
<p>Calling this method requires the caller to provide an ownership token of the corresponding container object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a73cacc8a6d3eacc8311717e165f25742" title="Takes ownership over the container.">Guard()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add. </td></tr>
    <tr><td class="paramname">token</td><td>The access token of this queue </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00146">146</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a71797322561c63ba4aeb434a37a3efd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71797322561c63ba4aeb434a37a3efd6">&#9670;&nbsp;</a></span>push() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this method takes ownership of the container for the duration of the push. If the container is currently owned by another thread, this method will block until the other thread releases the container. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#ae6eac66a1389b2415e962808db05498a" title="Adds an item to the end of the queue.">push(value_type const&amp;, access_token const&amp;)</a></dd></dl>
<p>This is a typical queue operation. The function creates an element at the end of the queue and assigns the given data to it. The time complexity of the operation depends on the underlying sequence. </p>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00112">112</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="ae6eac66a1389b2415e962808db05498a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eac66a1389b2415e962808db05498a">&#9670;&nbsp;</a></span>push() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a42c5dc5fdd27a44613833bffcb0147ad">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an item to the end of the queue. </p>
<p>Calling this method requires the caller to provide an ownership token of the corresponding container object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a73cacc8a6d3eacc8311717e165f25742" title="Takes ownership over the container.">Guard()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add. </td></tr>
    <tr><td class="paramname">token</td><td>The access token of this queue </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00132">132</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a70d0d18ccbf28c160b6dc67db6d5148c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d0d18ccbf28c160b6dc67db6d5148c">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns the number of elements in the concurrent_queue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00087">87</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a646b158ea2b71092746db61974cfb94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646b158ea2b71092746db61974cfb94a">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of elements in the concurrent_queue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00093">93</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="ab5a61a79a1797bbed734bf260fe0ad8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a61a79a1797bbed734bf260fe0ad8b">&#9670;&nbsp;</a></span>try_pop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::try_pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to remove the first element. </p>
<p>Tries to remove the foremost element. If no element is available, this method returns immediately with the result of false. </p><dl class="section return"><dt>Returns</dt><dd>True if an element could be removed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this method takes ownership of the container for the duration of the emplace. If the container is currently owned by another thread, this method will block until the other thread releases the container.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html#a98c3ce6d2656d2e6d7600d259ac8b111" title="Tries to remove the first element.">try_pop(T&amp;, access_token&amp;&amp;)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>If this method returns true this will hold the item removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item could be removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00206">206</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<a id="a98c3ce6d2656d2e6d7600d259ac8b111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c3ce6d2656d2e6d7600d259ac8b111">&#9670;&nbsp;</a></span>try_pop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">HORIZON::ALGORITHM::CONCURRENT::concurrent_queue</a>&lt; T, Container &gt;::try_pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__base.html#a5d82b4bcf23db039e00e34a1438e4576">access_token</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to remove the first element. </p>
<p>Tries to remove the foremost element. If no element is available, this method returns immediately with the result of false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>If this method returns true this will hold the item removed. </td></tr>
    <tr><td class="paramname">token</td><td>The access token of this queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item could be removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__queue_8hpp_source.html#l00216">216</a> of file <a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="concurrent__queue_8hpp_source.html">concurrent_queue.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_h_o_r_i_z_o_n.html">HORIZON</a></li><li class="navelem"><a class="el" href="namespace_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m.html">ALGORITHM</a></li><li class="navelem"><a class="el" href="namespace_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t.html">CONCURRENT</a></li><li class="navelem"><a class="el" href="class_h_o_r_i_z_o_n_1_1_a_l_g_o_r_i_t_h_m_1_1_c_o_n_c_u_r_r_e_n_t_1_1concurrent__queue.html">concurrent_queue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
